// SPDX-License-Identifier: GPL-2.0+
/*
 * Copyright 2017-2018, 2020-2023 NXP
 */

#include <common.h>
#include <command.h>
#include <spi.h>
#include <dm/device.h>
#include <dm/uclass.h>
#include <linux/errno.h>
#include <linux/kernel.h>
#include "sja1105_ll.h"

#define MAX_ARRAY_SIZE 30
//#define SJA1105_VAL_DEVICEID_1_1	0xAE00030EUL
#define SJA1105_VAL_DEVICEID_1_1	0xB700030Full

#ifndef CONFIG_DEFAULT_SPI_BUS
#   define CONFIG_DEFAULT_SPI_BUS	0
#endif


//#define SJA_DSPI_MODE	SPI_CPHA
//#define SJA_DSPI_HZ	4000000
#define SJA_DSPI_MODE	0
#define SJA_DSPI_HZ	1000000
#define SJA_DSPI_FMSZ	16

#define SWITCH_BASE_ADDR      0x000000ull
#define AIPS_ACRS_BASE_ADDR   0x1c0000ull
#define SMPU_BASE_ADDR        0x1c0400ull
#define T1_100BASE_BASE_ADDR  0x1c1000ull
// Goes from 1 to 4
#define SGMII_BASE_ADDR       0x1c1000ull
#define SGMII_PORT_BASE_ADDR(i) (SGMII_BASE_ADDR + i * 0x400ull)
#define TX_100BASE_BASE_ADDR  0x1c2400ull
#define OTP_CTRL_BASE_ADDR    0x1c4000ull
#define ACU_BASE_ADDR         0x1c4400ull
#define GPIO_BASE_ADDR        0x1c4800ull
#define RGU_BASE_ADDR         0x1c6000ull
#define CGU_BASE_ADDR         0x1c6400ull
#define PMU_BASE_ADDR         0x1c6800ull
#define SIU_BASE_ADDR         0x1c7c00ull

#define SGMII_BASE_REGISTER   0x3fc

#define SGMII_SR_MII_CTRL_BASE        0x1f00
#define SGMII_SR_MII_CTRL_OFFSET      0x00
#define SGMII_VR_MII_DIG_CTRL1_BASE   0x1f80
#define SGMII_VR_MII_DIG_CTRL1_OFFSET 0x00
#define SGMII_VR_MII_AN_CTRL_BASE     0x1f80
#define SGMII_VR_MII_AN_CTRL_OFFSET   0x01
#define SGMII_TXPLL_CONTROL_0_BASE    0x1f80
#define SGMII_TXPLL_CONTROL_0_OFFSET  0x6d
#define SGMII_TXPLL_CONTROL_1_BASE    0x1f80
#define SGMII_TXPLL_CONTROL_1_OFFSET  0x6e
#define SGMII_LANE_DRIVER1_0_BASE     0x1f80
#define SGMII_LANE_DRIVER1_0_OFFSET   0x38
#define SGMII_LANE_DRIVER2_0_BASE     0x1f80
#define SGMII_LANE_DRIVER2_0_OFFSET   0x3a
#define SGMII_LANE_DRIVER2_1_BASE     0x1f80
#define SGMII_LANE_DRIVER2_1_OFFSET   0x3b
#define SGMII_LANE_TRIM_BASE          0x1f80
#define SGMII_LANE_TRIM_OFFSET        0x40
#define SGMII_LANE_DATAPATH_1_BASE    0x1f80
#define SGMII_LANE_DATAPATH_1_OFFSET  0x37
#define SGMII_POWERDOWN_ENABLE_BASE   0x1f80
#define SGMII_POWERDOWN_ENABLE_OFFSET 0x41
#define SGMII_TXPLL_CONTROL_0_BASE    0x1f80
#define SGMII_TXPLL_CONTROL_0_OFFSET  0x6d
#define SGMII_RXPLL_CONTROL_0_BASE    0x1f80
#define SGMII_RXPLL_CONTROL_0_OFFSET  0x65
#define SGMII_RXPLL_CONTROL_1_BASE    0x1f80
#define SGMII_RXPLL_CONTROL_1_OFFSET  0x66
#define SGMII_RX_DATA_DETECT_BASE     0x1f80
#define SGMII_RX_DATA_DETECT_OFFSET   0x45
#define SGMII_RX_CDR_CTLE_BASE        0x1f80
#define SGMII_RX_CDR_CTLE_OFFSET      0x42
#define SGMII_SR_MII_STS_BASE         0x1f00
#define SGMII_SR_MII_STS_OFFSET       0x01



#define sja_debug(fmt, ...) \
	debug("[SJA1105]%s:%d " fmt, __func__, __LINE__, ##__VA_ARGS__)

#define SPI_NAME_PRINT_TEMPLATE "generic_%d:%d"

struct sja1105_cfgs_s {
	u32 devid;
	u32 cs;
	u32 bin_len;
	const u8 *cfg_bin;
};

static char *mac_lvl_counters1[] = {
	"N_RUNT         ",
	"N_SOFERR       ",
	"N_ALIGNERR     ",
	"N_MIIERR       ",
};

static char *mac_lvl_counters2[] = {
	"RSVD           ",
	"SPCERRS        ",
	"DRN664ERRS     ",
	"RSVD           ",
	"BAGDROP        ",
	"LENDROPS       ",
	"PORTDROPS      ",
	"RSVD           ",
	"SPCPRIOR       ",
	"RSVD           ",
};

static char *eth_high_lvl_counters1[] = {
	"N_TXBYTE       ",
	"N_TXBYTESH     ",
	"N_TXFRM        ",
	"N_TXFRMSH      ",
	"N_RXBYTE       ",
	"N_RXBYTESH     ",
	"N_RXFRM        ",
	"N_RXFRMSH      ",
	"N_POLERR       ",
	"RSVD           ",
	"RSVD           ",
	"N_CRCERR       ",
	"N_SIZERR       ",
	"RSVD           ",
	"N_VLANERR      ",
	"N_N664ERR      ",
};

static char *eth_high_lvl_counters2[] = {
	"N_NOT_REACH    ",
	"N_ERG_DISABLED ",
	"N_PART_DROP    ",
	"N_QFULL        ",
};

struct sja_parms {
	u32 bus;
	u32 cs;
	u32 devid;
	u32 bin_len;
	const u8 *cfg_bin;
};

static struct spi_slave *get_spi_slave(struct sja_parms *sjap)
{
	struct spi_slave *slave;
	int ret;
	char name[MAX_ARRAY_SIZE + 1];
	struct udevice *dev;

	name[MAX_ARRAY_SIZE] = 0;
	ret = snprintf(name, sizeof(name) - 1, SPI_NAME_PRINT_TEMPLATE,
		       sjap->bus, sjap->cs);
	if (ret > MAX_ARRAY_SIZE)
		return NULL;

	ret = spi_get_bus_and_cs(sjap->bus, sjap->cs, SJA_DSPI_HZ,
				 SJA_DSPI_MODE, "spi_generic_drv",
				 name, &dev, &slave);
	if (ret)
		return NULL;
	/*
	 * spi_get_bus_and_cs does not populate max_hz, mode and wordlen fields
	 * when there is a node in dts.
	 * In order to maintain the compatibility with the DM version of
	 * the driver, these fields should be assigned manually.
	 */
	slave->max_hz = SJA_DSPI_HZ;
	slave->mode = SJA_DSPI_MODE;
	slave->wordlen = SJA_DSPI_FMSZ;
	return slave;
}

static int sja1105_write(struct sja_parms *sjap, u32 *cmd, u8 nb_words)
{
	struct spi_slave *slave;
	int bitlen = (nb_words << 3) << 2;
	int ret = 0;

	slave = get_spi_slave(sjap);
	if (!slave) {
		printf("Invalid device %d:%d\n", sjap->bus, sjap->cs);
		return -EINVAL;
	}

	ret = spi_claim_bus(slave);
	if (ret) {
		printf("Error %d while claiming bus\n", ret);
		goto done;
	}

	ret = spi_xfer(slave, bitlen, cmd, NULL,
		       SPI_XFER_BEGIN | SPI_XFER_END);

	if (ret)
		printf("Error %d during SPI transaction\n", ret);

done:
	spi_release_bus(slave);

	return ret;
}

static u32 swap_words16(u32 swap_val)
{
	u32 upper, lower;

	upper = (swap_val & GENMASK(15, 0)) << 16;
	lower = (swap_val & GENMASK(31, 16)) >> 16;
	return upper | lower;
}

static int sja1105_cfg_block_write(struct sja_parms *sjap, u32 reg_addr,
				   u32 *data, int nb_words)
{
	u32 cmd[SJA1105_CONFIG_WORDS_PER_BLOCK + 1] = { 0 };
	int i = 0;

	cmd[0] = cpu_to_le32(CMD_ENCODE_RWOP(CMD_WR_OP) |
			      CMD_ENCODE_ADDR(reg_addr));
	cmd[0] = swap_words16(cmd[0]);

	while (i < nb_words) {
		cmd[i + 1] = swap_words16(*data++);
		sja_debug("config write 0x%08x\n", cmd[i + 1]);
		i++;
	}

	return sja1105_write(sjap, cmd, nb_words + 1);
}

static u32 sja1105_read_reg32_v2(struct sja_parms *sjap, u32 base, u32 offset)
{
	u32 cmd[2] = { 0 }, resp[2] = { 0 };
	struct spi_slave *slave;
	int bitlen = sizeof(cmd) << 3;
	int rc;

	//printf("READ\n");

	// Apparently the addresses in the datasheet are * 4 compared
	// to what theyn eed to be on the wire...
	offset = offset / 4;

	slave = get_spi_slave(sjap);
	if (!slave) {
		printf("Invalid device %d:%d\n", sjap->bus, sjap->cs);
		return -EINVAL;
	}

	rc = spi_claim_bus(slave);
	if (rc)
		goto done;

	cmd[0] = cpu_to_le32(CMD_ENCODE_RWOP(CMD_RD_OP) |
		CMD_ENCODE_ADDR(base + offset) | CMD_ENCODE_WRD_CNT(1));
	cmd[1] = 0;
	cmd[0] = swap_words16(cmd[0]);

	//printf("cmd[0] = 0x%x cmd[1] = 0x%x\n", cmd[0], cmd[1]);
	rc = spi_xfer(slave, bitlen, cmd, resp,
		      SPI_XFER_BEGIN | SPI_XFER_END);
	if (rc)
		printf("Error %d during SPI transaction\n", rc);
	spi_release_bus(slave);

	//printf("#before swap#LE32# sja1105_read_reg35. resp: 0x%x 0x%x\n", resp[0], resp[1]);
	resp[1] = swap_words16(resp[1]);
	//printf("resp[0] = 0x%x resp[1] = 0x%x\n", resp[0], resp[1]);

	return le32_to_cpu(resp[1]);
done:
	return rc;
}


static u32 sja1105_read_reg32(struct sja_parms *sjap, u32 reg_addr)
{
	u32 cmd[2] = { 0 }, resp[2] = { 0 };
	struct spi_slave *slave;
	int bitlen = sizeof(cmd) << 3;
	int rc;

	sja_debug("reading 4bytes @0x%08x tlen %d t.bits_per_word %d\n",
		  reg_addr, 8, 64);

	slave = get_spi_slave(sjap);
	if (!slave) {
		printf("Invalid device %d:%d\n", sjap->bus, sjap->cs);
		return -EINVAL;
	}

	rc = spi_claim_bus(slave);
	if (rc)
		goto done;

	cmd[0] = cpu_to_le32(CMD_ENCODE_RWOP(CMD_RD_OP) |
		CMD_ENCODE_ADDR(reg_addr) | CMD_ENCODE_WRD_CNT(1));
	cmd[1] = 0;
	cmd[0] = swap_words16(cmd[0]);

	//printf("cmd[0] = 0x%x cmd[1] = 0x%x\n", cmd[0], cmd[1]);
	rc = spi_xfer(slave, bitlen, cmd, resp,
		      SPI_XFER_BEGIN | SPI_XFER_END);
	if (rc)
		printf("Error %d during SPI transaction\n", rc);
	spi_release_bus(slave);

	resp[1] = swap_words16(resp[1]);
	//printf("resp[0] = 0x%x resp[1] = 0x%x\n", resp[0], resp[1]);
	return le32_to_cpu(resp[1]);
done:
	return rc;
}

static int sja1105_write_reg32_v2(struct sja_parms *sjap, u32 base, u32 offset, u32 val)
{
	u32 cmd[2] = { 0 }, resp[2] = { 0 };
	struct spi_slave *slave;
	int bitlen = sizeof(cmd) << 3;
	int rc;

	//printf("WRITE\n");
	offset = offset / 4;

	slave = get_spi_slave(sjap);
	if (!slave) {
		printf("Invalid device %d:%d\n", sjap->bus, sjap->cs);
		return -EINVAL;
	}

	rc = spi_claim_bus(slave);
	if (rc) {
		printf("Failed to claim bus\n");
		goto done;
	}

	cmd[0] = cpu_to_le32(CMD_ENCODE_RWOP(CMD_WR_OP) |
		CMD_ENCODE_ADDR(base + offset) | CMD_ENCODE_WRD_CNT(1));
	cmd[0] = swap_words16(cmd[0]);
	cmd[1] = swap_words16(val);

	//printf("cmd[0] = 0x%x cmd[1] = 0x%x\n", cmd[0], cmd[1]);
	rc = spi_xfer(slave, bitlen, cmd, resp,
		      SPI_XFER_BEGIN | SPI_XFER_END);
	if (rc)
		printf("Error %d during SPI transaction\n", rc);
	spi_release_bus(slave);

	resp[1] = swap_words16(resp[1]);

	return le32_to_cpu(resp[1]);
done:
	return rc;
}

static int sja1105_write_reg32(struct sja_parms *sjap, u32 reg_addr, u32 val)
{
	u32 cmd[2] = { 0 }, resp[2] = { 0 };
	struct spi_slave *slave;
	int bitlen = sizeof(cmd) << 3;
	int rc;

	sja_debug("writing 4bytes @0x%08x tlen %d t.bits_per_word %d\n",
		  reg_addr, 8, 64);

	slave = get_spi_slave(sjap);
	if (!slave) {
		printf("Invalid device %d:%d\n", sjap->bus, sjap->cs);
		return -EINVAL;
	}

	rc = spi_claim_bus(slave);
	if (rc) {
		printf("Failed to claim bus\n");
		goto done;
	}

	cmd[0] = cpu_to_le32(CMD_ENCODE_RWOP(CMD_WR_OP) |
		CMD_ENCODE_ADDR(reg_addr) | CMD_ENCODE_WRD_CNT(1));
	cmd[0] = swap_words16(cmd[0]);
	cmd[1] = swap_words16(val);

	rc = spi_xfer(slave, bitlen, cmd, resp,
		      SPI_XFER_BEGIN | SPI_XFER_END);
	if (rc)
		printf("Error %d during SPI transaction\n", rc);
	spi_release_bus(slave);

	resp[1] = swap_words16(resp[1]);

	return le32_to_cpu(resp[1]);
done:
	return rc;
}

static bool sja1105_check_device_status(struct sja_parms *sjap,
					bool expected_status, bool *pstatus)
{
	u32 status;
	u32 expected_val = expected_status ? SJA1105_BIT_STATUS_CONFIG_DONE : 0;
	bool ret = true;
	u32 error;

	status = sja1105_read_reg32(sjap, SJA1105_REG_STATUS);

	/* Check status is valid: check if any error bit is set */
	error = SJA1105_BIT_STATUS_CRCCHKL |
		 SJA1105_BIT_STATUS_DEVID_MATCH |
		 SJA1105_BIT_STATUS_CRCCHKG;
	if (status & error) {
		sja_debug("Error: SJA1105_REG_STATUS=0x%08x - LocalCRCfail=%d - DevID unmatched=%d, GlobalCRCfail=%d\n",
			  status,
			  (int)(status & SJA1105_BIT_STATUS_CRCCHKL),
			  (int)(status & SJA1105_BIT_STATUS_DEVID_MATCH),
			  (int)(status & SJA1105_BIT_STATUS_CRCCHKG));
		return false;
	}

	*pstatus = (expected_val == (status & SJA1105_BIT_STATUS_CONFIG_DONE));

	if (expected_status && !*pstatus)
		ret = false;

	return ret;
}

static int sja1105_check_device_id(struct sja_parms *sjap)
{
	return sja1105_read_reg32(sjap, SJA1105_REG_DEVICEID);
}

bool sja1105_post_cfg_load_check(struct sja_parms *sjap)
{
	u32 chip_id;
	bool status;

	/* Trying to read back the SJA1105 status via SPI... */
	chip_id  = sja1105_check_device_id(sjap);
	if (sjap->devid != chip_id)
		return false;
	if (!sja1105_check_device_status(sjap, true, &status))
		return false;

	return status;
}

static int display_status_regs(struct sja_parms *sjap) {
	u32 val;

	val = sja1105_read_reg32_v2(sjap, 0x0, 0x280);
	printf("IRQ_STAT1: 0x%x\n", val);
	val = sja1105_read_reg32_v2(sjap, 0x0, 0x284);
	printf("IRQ_STAT2: 0x%x\n", val);
	val = sja1105_read_reg32_v2(sjap, 0x0, 0x288);
	printf("IRQ_STAT3: 0x%x\n", val);
	val = sja1105_read_reg32_v2(sjap, 0x0, 0x28c);
	printf("IRQ_STAT4: 0x%x\n", val);
	val = sja1105_read_reg32_v2(sjap, 0x0, 0x290);
	printf("IRQ_STAT5: 0x%x\n", val);
	val = sja1105_read_reg32_v2(sjap, 0x0, 0x294);
	printf("IRQ_STAT6: 0x%x\n", val);
	val = sja1105_read_reg32_v2(sjap, 0x0, 0x298);
	printf("IRQ_STAT7: 0x%x\n", val);
	val = sja1105_read_reg32_v2(sjap, 0x0, 0x29c);
	printf("IRQ_STAT8: 0x%x\n", val);
}

static void sja1105_en_rgmii_txid_by_default(struct sja_parms *sjap, int port)
{
	u32 id;
	u32 reg = SJA1105_CFG_PAD_MIIX_ID_PORT(port);

	id = sja1105_read_reg32(sjap, reg);

	if (id & (SJA1105_CFG_PAD_MIIX_ID_TXC_PD |
				SJA1105_CFG_PAD_MIIX_ID_TXC_BYPASS)) {
		id &= ~GENMASK(7, 0);
		id |= SJA1105_CFG_PAD_MIIX_ID_RGMII_TXID;
		sja1105_write_reg32(sjap, reg, id);
	}
}

static void sja1105_set_rgmii_clock(struct sja_parms *sjap, int port, int speed)
{
	u32 divisor = 0U;

	/* Set slew rate of TX Pins to high speed */
	sja1105_write_reg32(sjap,
			    SJA1105_CFG_PAD_MIIX_TX_PORT(port),
			    SJA1105_CFG_PAD_MIIX_TX_SLEW_RGMII);

	/* Set IDIV divisor (IDIV = divisor + 1) */
	if (speed == SJA1105_REG_MAC_SPEED_10M)
		divisor = 9U;
	else if (speed == SJA1105_REG_MAC_SPEED_100M)
		divisor = 0U;

	switch (speed) {
	case SJA1105_REG_MAC_SPEED_1G:
	case SJA1105_REG_MAC_SPEED_DISABLED:
		/* Set Clock delay */
		sja1105_en_rgmii_txid_by_default(sjap, port);
		/* Disable IDIV */
		sja1105_write_reg32(sjap, SJA1105_CGU_IDIV_PORT(port),
				    SJA1105_CGU_IDIV_DISABLE);

		/* Set Clock source to PLL0 125MHz */
		sja1105_write_reg32(sjap,
				    SJA1105_CGU_MII_TX_CLK_PORT(port),
				    SJA1105_CGU_MII_CLK_SRC_PLL0);
		break;
	case SJA1105_REG_MAC_SPEED_100M:
	case SJA1105_REG_MAC_SPEED_10M:
		/* Set Clock delay */
		sja1105_write_reg32(sjap,
				    SJA1105_CFG_PAD_MIIX_ID_PORT(port),
				    SJA1105_CFG_PAD_MIIX_ID_RGMII_SLOW);

		/* Enable IDIV with divisor */
		sja1105_write_reg32(sjap, SJA1105_CGU_IDIV_PORT(port),
				    SJA1105_CGU_IDIV_ENABLE |
				    ENCODE_REG_IDIV_IDIV(divisor));

		/* Set Clock source to IDIV (25Mhz XTAL / (divisor + 1))*/
		sja1105_write_reg32(sjap,
				    SJA1105_CGU_MII_TX_CLK_PORT(port),
				    SJA1105_CGU_MII_SRC_IDIV(port));
		break;
	default:
		pr_err("speed not supported");
	}
}

void sja1105_port_cfg(struct sja_parms *sjap)
{
	u32 i;

	for (i = 0; i < SJA1105_PORT_NB; i++) {
		u32 port_status;

		/* Get port type / speed */
		port_status = sja1105_read_reg32(sjap,
						 SJA1105_PORT_STATUS_MII_PORT(i));

		switch (port_status & SJA1105_PORT_STATUS_MII_MODE) {
		case e_mii_mode_rgmii:
			/* 1G sets the port to default configuration */
			sja1105_set_rgmii_clock(sjap, i,
						SJA1105_REG_MAC_SPEED_1G);
			break;

		default:
			break;
		}
	}
}

static void sja1105_set_speed_reg(struct sja_parms *sjap, int port, u32 speed)
{
	u32 reg_val, mode;

	/* Get port type / speed */
	mode = sja1105_read_reg32(sjap,
				  SJA1105_PORT_STATUS_MII_PORT(port));

	switch (mode & SJA1105_PORT_STATUS_MII_MODE) {
	case e_mii_mode_rgmii:
		/* Swap to configuration for required port*/
		sja1105_write_reg32(sjap, SJA1105_REG_MAC_RECONF0,
				    SJA1105_BIT_MAC_RECONF0_PORT(port) |
				    SJA1105_BIT_MAC_RECONF0_VALID);

		/* Read current content of register and update speed */
		reg_val = sja1105_read_reg32(sjap, SJA1105_REG_MAC_RECONF5);
		reg_val &= ~SJA1105_REG_MAC_SPEED_MASK;
		reg_val |= SJA1105_REG_MAC_RECONF5_SPEED(speed);
		sja1105_write_reg32(sjap, SJA1105_REG_MAC_RECONF5, reg_val);

		/* Write configuration back */
		sja1105_write_reg32(sjap,
				    SJA1105_REG_MAC_RECONF0,
				    SJA1105_BIT_MAC_RECONF0_WRITE |
				    SJA1105_BIT_MAC_RECONF0_PORT(port) |
				    SJA1105_BIT_MAC_RECONF0_VALID);

		/* Check error */
		reg_val = sja1105_read_reg32(sjap, SJA1105_REG_MAC_RECONF0);
		if (reg_val & SJA1105_BIT_MAC_RECONF0_ERR) {
			pr_err("speed on port %d could't be updated", port);
			return;
		}

		/* Update Clock Generation Unit registers */
		sja1105_set_rgmii_clock(sjap, port, speed);
		break;
	default:
		pr_err("only RGMII is supported");
		break;
	}
}

static u32 sja1105_get_speed_reg(struct sja_parms *sjap, int port)
{
	u32 reg_val;
	/* Swap to configuration for required port*/
	sja1105_write_reg32(sjap, SJA1105_REG_MAC_RECONF0,
			    SJA1105_BIT_MAC_RECONF0_PORT(port) |
			    SJA1105_BIT_MAC_RECONF0_VALID);

	/* Read current content of register and update speed */
	reg_val = sja1105_read_reg32(sjap, SJA1105_REG_MAC_RECONF5);

	return ((SJA1105_REG_MAC_SPEED_MASK & reg_val) >>
		SJA1105_REG_MAC_SPEED_SHIFT);
}

static bool sja1105_parse_speed(char *str, u32 *speed)
{
	if (!strcmp(str, "10M"))
		*speed = SJA1105_REG_MAC_SPEED_10M;
	else if (!strcmp(str, "100M"))
		*speed = SJA1105_REG_MAC_SPEED_100M;
	else if (!strcmp(str, "1G"))
		*speed = SJA1105_REG_MAC_SPEED_1G;
	else if (!strcmp(str, "disable"))
		*speed = SJA1105_REG_MAC_SPEED_DISABLED;
	else if (!strcmp(str, "-"))
		*speed = -1;
	else
		return false;
	return true;
}

static int sja1105_configuration_load(struct sja_parms *sjap)
{
	int remaining_words;
	int nb_words;
	u32 *data;
	u32 dev_addr;
	u32 val;
	bool swap_required;
	int i;
	int ret;

	printf("#### loading configuration\n");
	if (!sjap->cfg_bin) {
		printf("Error: SJA1105 Switch configuration is NULL\n");
		return -EINVAL;
	}

	if (sjap->bin_len == 0) {
		printf("Error: SJA1105 Switch configuration is empty\n");
		return -EINVAL;
	}

	if (sjap->bin_len % 4 != 0) {
		printf("Error: SJA1105 Switch configuration is not valid\n");
		return -EINVAL;
	}

	data = (u32 *)&sjap->cfg_bin[0];

	nb_words = (sjap->bin_len >> 2);

	val = data[0];

	if (val == __builtin_bswap32(sjap->devid)) {
		printf("Config bin requires swap, incorrect endianness\n");
		swap_required = true;
	} else if (val == sjap->devid) {
		swap_required = false;
	} else {
		printf("Error: SJA1105 unhandled revision Switch incompatible configuration file (%x - %x)\n",
		       val, sjap->devid);
		return -EINVAL;
	}

	if (swap_required)
		for (i = 0; i < nb_words; i++) {
			val = data[i];
			data[i] = __builtin_bswap32(val);
		}

	sja_debug("swap_required %d nb_words %d dev_addr 0x%08x\n",
		  swap_required, nb_words, (u32)SJA1105_CONFIG_START_ADDRESS);

	remaining_words = nb_words;
	dev_addr = SJA1105_CONFIG_START_ADDRESS;

	printf("Displaying IRQ_STAT regs before SW core reset\n");
	display_status_regs(sjap);

	printf("### Performing switch core reset before config load\n");
	ret = sja1105_write_reg32_v2(sjap, RGU_BASE_ADDR, 0x100, 0x100000);
	if (ret < 0) {
		printf("#### Error resetting switch core\n");
		return ret;
	}
	// Wait for the switch to come out of reset
	udelay(1000);
	printf("Displaying IRQ_STAT regs after SW core reset, before loading config\n");
	display_status_regs(sjap);


	i = 0;
	while (remaining_words > 0) {
		int block_size_words =
			min(SJA1105_CONFIG_WORDS_PER_BLOCK, remaining_words);

		sja_debug("block_size_words %d remaining_words %d\n",
			  block_size_words, remaining_words);

		if (sja1105_cfg_block_write(sjap, dev_addr, data,
					    block_size_words) < 0)
			return 1;

		sja_debug("Loaded block %d @0x%08x\n", i, dev_addr);

		dev_addr += block_size_words;
		data += block_size_words;
		remaining_words -= block_size_words;
		i++;

		if (i % 10 == 0)
			sja1105_post_cfg_load_check(sjap);
	}

	printf("Displaying IRQ_STAT regs after loading config\n");
	display_status_regs(sjap);

	if (!sja1105_post_cfg_load_check(sjap)) {
		printf("SJA1105 configuration failed\n");
		return -ENXIO;
	}

	//TODO! Is this needed????
	//sja1105_port_cfg(sjap);

	return 0;
}

static bool sja1105_speed_control(struct udevice *dev, char *options)
{
	int port;
	struct sja_parms *sjap = dev_get_priv(dev);
	u32 speed[SJA1105_PORT_NB] = {-1, -1, -1, -1, -1};
	char *tok;
	static const char * const speed_str[] = {"Disabled",
						 "1G",
						 "100M",
						 "10M"};

	if (!sjap)
		return false;

	switch (sja1105_check_device_id(sjap)) {
	case SJA1105_DEV_COMPATIBLE_PRx:
	case SJA1105_DEV_COMPATIBLE_QSx:
		break;
	default:
		pr_err("command not supported on this device");
		return false;
	}

	if (options) {
		/* Additional parameter to set speed */
		tok = strtok(options, ",");
		for (port = 0; port < SJA1105_PORT_NB; ++port) {
			if (!tok)
				break;

			if (!sja1105_parse_speed(tok, &speed[port])) {
				pr_err("invalid speed on port %d", port);
				return false;
			}

			tok = strtok(NULL, ",");
		}

		/* Update registers */
		for (port = 0; port < SJA1105_PORT_NB; ++port)
			if (-1 != speed[port])
				sja1105_set_speed_reg(sjap, port, speed[port]);
	}

	for (port = 0; port < SJA1105_PORT_NB; ++port)
		speed[port] = sja1105_get_speed_reg(sjap, port);

	printf("port0:%s port1:%s port2:%s port3:%s port4:%s\n",
	       speed_str[speed[0]], speed_str[speed[1]], speed_str[speed[2]],
	       speed_str[speed[3]], speed_str[speed[4]]);

	return true;
}

static void sja1105_reset_ports(struct udevice *dev)
{
	struct sja_parms *sjap = dev_get_priv(dev);
	int i, val;

	if (!sjap)
		return;

	for (i = 0; i < SJA1105_PORT_NB; i++) {
		val = sja1105_read_reg32(sjap,
					 SJA1105_CFG_PAD_MIIX_ID_PORT(i));

		/* If the RXID is disabled, skip the port */
		if (val & SJA1105_CFG_PAD_MIIX_ID_RXC_PD ||
		    val & SJA1105_CFG_PAD_MIIX_ID_RXC_BYPASS)
			continue;

		/* Toggle RX Internal delay PowerDown and Bypass */
		val |= SJA1105_CFG_PAD_MIIX_ID_RXC_PD;
		val |= SJA1105_CFG_PAD_MIIX_ID_RXC_BYPASS;

		sja1105_write_reg32(sjap, SJA1105_CFG_PAD_MIIX_ID_PORT(i),
				    val);

		val &= ~SJA1105_CFG_PAD_MIIX_ID_RXC_PD;
		val &= ~SJA1105_CFG_PAD_MIIX_ID_RXC_BYPASS;

		sja1105_write_reg32(sjap, SJA1105_CFG_PAD_MIIX_ID_PORT(i),
				    val);
	}
}

static int init_config(struct udevice *dev)
{
	struct sja_parms *sjap = dev_get_priv(dev);
	ulong driver_data = dev_get_driver_data(dev);
	struct sja1105_cfgs_s *cfg = (struct sja1105_cfgs_s *)driver_data;
	int i = 0;

	if (!sjap)
		return -EINVAL;

	for (i = 0; cfg[i].cfg_bin; i++) {
		if (cfg[i].devid == sjap->devid && cfg[i].cs == sjap->cs) {
			sjap->bin_len = cfg[i].bin_len;
			sjap->cfg_bin = cfg[i].cfg_bin;
			return 0;
		}
	}

	printf("No matching device ID found for devid %X, cs %d.\n",
	       sjap->devid, sjap->cs);

	return -EINVAL;
}

static int load_config_file(struct udevice *dev)
{
	struct sja_parms *sjap = dev_get_priv(dev);
	int cs = spi_chip_select(dev);
	int bus = dev->parent->seq_;
	int ret;

	printf("Loading SJA1105 firmware over SPI %d:%d\n", bus, cs);

	ret = init_config(dev);
	if (ret) {
		printf("Error SJA1105 configuration not completed\n");
		return -EINVAL;
	} else {
		printf("Loading firmware succesful\n");
	}

	return sja1105_configuration_load(sjap);
}

#define BASE_TIMER_CLK_OUTCLK_7_C 0x74
#define BASE_MCSS_CLK_OUTCLK_6_C  0x70
static int sja11105_dm_probe(struct udevice *dev)
{
	struct sja_parms *sjap = dev_get_priv(dev);
	int cs = spi_chip_select(dev);
	int bus = dev->parent->seq_;
	int ret;

	if (!sjap)
		return -EINVAL;

	if (cs < 0)
		return cs;

	sjap->cs = cs;
	sjap->bus = bus;
	sjap->devid = sja1105_check_device_id(sjap);

	sja_debug("devid %X\n", sjap->devid);

	if (sja1105_post_cfg_load_check(sjap)) {
		printf("SJA1105 configuration already done.\n");
	}

	// Power down the BASE_TIMER_CLK to disable the watchdog timer
	ret = sja1105_write_reg32_v2(sjap, CGU_BASE_ADDR, BASE_TIMER_CLK_OUTCLK_7_C, 0x1);
	if (ret < 0) {
		printf("Error powering down BASE_TIMER_CLK\n");
		return ret;
	}
	/* Power down the BASE_MCSS_CLOCK to gate the microcontroller off */
	ret = sja1105_write_reg32_v2(sjap, CGU_BASE_ADDR, BASE_MCSS_CLK_OUTCLK_6_C, 0x1);
	if (ret < 0) {
		printf("Error powering down BASE_MCSS_CLK\n");
		return ret;
	}

	return load_config_file(dev);
}



static void sja1105_print_general_status_regs(struct sja_parms *sjap)
{
	u32 val32;
	int i, sja1105_gen_reg_status_nr, offset = -1;

	printf("\nGeneral Status\n");
	for (i = SJA1105_REG_GENERAL_STATUS1; i < SJA1105_REG_GENERAL_STATUS9; i++) {
		if (i == SJA1105_REG_GENERAL_STATUS_NA) {
			offset++;
			continue;
		}

		val32 = sja1105_read_reg32(sjap, i);
		sja1105_gen_reg_status_nr = i - SJA1105_REG_GENERAL_STATUS1 - offset;
		printf("general_status_%d    = %08x\n", sja1105_gen_reg_status_nr, val32);
	}
}

static void sja1105_print_char_arr(struct sja_parms *sjap,
				   char *buffer[], int size, int port)
{
	int i;
	u32 val32, mask, shr_value = -1U;
	u32 reg_read_value;
	bool read_again, shr_needed;

	if (buffer == mac_lvl_counters1) {
		reg_read_value = SJA1105_REG_PORT_MAC_STATUS(port);
		read_again = false;
		mask = GENMASK(7, 0);
		shr_needed = true;
		shr_value = 8;
	}

	if (buffer == mac_lvl_counters2) {
		reg_read_value = SJA1105_REG_PORT_MAC_STATUS(port) + 1;
		read_again = false;
		mask = GENMASK(1, 0);
		shr_needed = true;
		shr_value = 1;
	}

	if (buffer == eth_high_lvl_counters1) {
		reg_read_value = SJA1105_REG_PORT_HIGH_STATUS1(port);
		read_again = true;
		mask = GENMASK(31, 0);
		shr_needed = false;
		shr_value = 0;
	}

	if (buffer == eth_high_lvl_counters2) {
		reg_read_value = SJA1105_REG_PORT_HIGH_STATUS2(port);
		read_again = true;
		mask = GENMASK(31, 0);
		shr_needed = false;
		shr_value = 0;
	}

	if (shr_value == -1U)
		return;

	val32 = sja1105_read_reg32(sjap, reg_read_value);
	for (i = 0; i < size; i++) {
		printf("port%d %s    = %u\n", port, buffer[i],
		       (val32 >> (i * shr_needed * shr_value)) & mask);

		if (read_again && i + 1 < size)
			val32 = sja1105_read_reg32(sjap, reg_read_value + i + 1);
	}
}

static void sja1105_print_level_counters(struct sja_parms *sjap)
{
	int i;

	for (i = 0; i < SJA1105_PORT_NB; i++) {
		printf("\nEthernet MAC-level status port%d\n", i);
		sja1105_print_char_arr(sjap, mac_lvl_counters1,
				       ARRAY_SIZE(mac_lvl_counters1), i);
		sja1105_print_char_arr(sjap, mac_lvl_counters2,
				       ARRAY_SIZE(mac_lvl_counters2), i);
	}

	for (i = 0; i < SJA1105_PORT_NB; i++) {
		printf("\nEthernet High-level status port%d\n", i);
		sja1105_print_char_arr(sjap, eth_high_lvl_counters1,
				       ARRAY_SIZE(eth_high_lvl_counters1), i);
		sja1105_print_char_arr(sjap, eth_high_lvl_counters2,
				       ARRAY_SIZE(eth_high_lvl_counters2), i);
	}
}

static void sja1105_print_internal_delay_status(struct sja_parms *sjap)
{
	u32 val32;
	int i;

	printf("\nInternal delay status\n");

	for (i = 0; i < SJA1105_PORT_NB; i++) {
		val32 = sja1105_read_reg32(sjap,
					   SJA1105_CFG_PAD_MIIX_ID_PORT(i));
		printf("CFG_PAD_MII%d_ID 0x%x\n", i, val32);
	}
}

static int sja1105_print_info(struct udevice *dev)
{
	struct sja_parms *sjap = dev_get_priv(dev);

	if (!sjap)
		return -EINVAL;

	sja1105_print_general_status_regs(sjap);
	sja1105_print_level_counters(sjap);
	sja1105_print_internal_delay_status(sjap);
	return 0;
}

static const unsigned char insides_of_uc_m2_bin[] = {
  0x0f, 0x03, 0x00, 0xb7,
  0x00, 0x00, 0x00, 0x06,
  0xdc, 0x00, 0x00, 0x00,
  0xe8, 0x2c, 0xe0, 0x86,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x00,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x02,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x04,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x06,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x08,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x0a,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x0c,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x0e,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x10,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x12,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x14,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x16,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x18,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x1a,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x1c,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x1e,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x20,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x22,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x24,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x26,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x28,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x2a,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x2c,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x2e,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x30,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x32,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x34,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x36,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x38,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x3a,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x3c,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x3e,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x40,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x42,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x44,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x46,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x48,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x4a,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x4c,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x4e,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x50,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x52,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x54,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x56,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x58,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x5a,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x5c,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x5e,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x60,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x62,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x64,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x66,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x68,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x6a,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x6c,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x6e,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x70,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x72,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x74,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x76,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x78,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x7a,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x7c,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x7e,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x80,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x82,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x84,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x86,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x88,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x8a,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x8c,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x8e,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x90,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x92,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x94,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x96,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x98,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x9a,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x9c,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0x9e,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xa0,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xa2,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xa4,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xa6,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xa8,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xaa,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xac,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xae,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xb0,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xb2,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xb4,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xb6,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xb8,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xba,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xbc,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xbe,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xc0,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xc2,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xc4,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xc6,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xc8,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xca,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xcc,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xce,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xd0,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xd2,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xd4,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xd6,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xd8,
  0x00, 0xec, 0xff, 0xff,
  0x9f, 0xff, 0x7f, 0xda,
  0xfb, 0x10, 0x28, 0xa5,
  0x00, 0x00, 0x00, 0x07,
  0x21, 0x00, 0x00, 0x00,
  0x22, 0xcb, 0x8c, 0xcf,
  0x00, 0x00, 0x00, 0x00,
  0x80, 0x01, 0xf0, 0xff,
  0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x28,
  0x83, 0xff, 0xff, 0xff,
  0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x30,
  0x83, 0xff, 0xff, 0xff,
  0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x38,
  0x83, 0xff, 0xff, 0xff,
  0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x40,
  0x83, 0xff, 0xff, 0xff,
  0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x48,
  0x83, 0x55, 0xf0, 0xff,
  0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x50,
  0x83, 0xff, 0xff, 0xff,
  0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x58,
  0x83, 0xff, 0xff, 0xff,
  0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x60,
  0x83, 0xff, 0xff, 0xff,
  0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x68,
  0x83, 0xff, 0xff, 0xff,
  0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x70,
  0x83, 0xff, 0xff, 0xff,
  0xff, 0x03, 0x00, 0x00,
  0x7b, 0xaf, 0x94, 0xb8,
  0x00, 0x00, 0x00, 0x08,
  0x26, 0x00, 0x00, 0x00,
  0x4a, 0x64, 0x0b, 0xd0,
  0x00, 0x00, 0x00, 0x00,
  0xff, 0xfb, 0xdf, 0xff,
  0x00, 0x00, 0x00, 0x80,
  0xfe, 0xf7, 0xbf, 0xff,
  0x00, 0x00, 0x00, 0x80,
  0xfd, 0xef, 0x7f, 0xff,
  0x00, 0x00, 0x00, 0x80,
  0xfb, 0xdf, 0xff, 0xfe,
  0x00, 0x00, 0x00, 0x80,
  0xf7, 0xbf, 0xff, 0xfd,
  0x00, 0x00, 0x00, 0x80,
  0xef, 0x7f, 0xff, 0xfb,
  0x00, 0x00, 0x00, 0x80,
  0xdf, 0xff, 0xfe, 0xf7,
  0x00, 0x00, 0x00, 0x80,
  0xbf, 0xff, 0xfd, 0xef,
  0x00, 0x00, 0x00, 0x80,
  0x7f, 0xff, 0xfb, 0xdf,
  0x00, 0x00, 0x00, 0x80,
  0xff, 0xfe, 0xf7, 0xbf,
  0x00, 0x00, 0x00, 0x80,
  0xff, 0xfd, 0xef, 0x7f,
  0x00, 0x00, 0x00, 0x40,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xc0,
  0x24, 0x49, 0x92, 0x24,
  0x00, 0x00, 0x00, 0x40,
  0x49, 0x92, 0x24, 0x49,
  0x00, 0x00, 0x00, 0xc0,
  0x6d, 0xdb, 0xb6, 0x6d,
  0x00, 0x00, 0x00, 0x40,
  0x92, 0x24, 0x49, 0x92,
  0x00, 0x00, 0x00, 0xc0,
  0xb6, 0x6d, 0xdb, 0xb6,
  0x00, 0x00, 0x00, 0x40,
  0xdb, 0xb6, 0x6d, 0xdb,
  0x00, 0x00, 0x00, 0xc0,
  0xff, 0xff, 0xff, 0xff,
  0x4c, 0xe9, 0xe6, 0x5b,
  0x00, 0x00, 0x00, 0x09,
  0x58, 0x00, 0x00, 0x00,
  0x55, 0x9a, 0x8b, 0x66,
  0x00, 0x00, 0x00, 0xc0,
  0x01, 0x00, 0x00, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x03, 0x01, 0xfc, 0x08,
  0xe4, 0x4f, 0x40, 0xbf,
  0x02, 0xfb, 0x17, 0xe0,
  0xcf, 0x40, 0xff, 0x06,
  0xfc, 0x3b, 0xf0, 0xff,
  0x00, 0x00, 0x00, 0xc0,
  0x01, 0x00, 0x00, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0xfc, 0x08,
  0xe4, 0x4f, 0x40, 0xbf,
  0x02, 0xfb, 0x17, 0xe0,
  0xcf, 0x40, 0xff, 0x06,
  0xfc, 0x3b, 0xf0, 0xff,
  0x00, 0x00, 0x00, 0xc0,
  0x01, 0x00, 0x00, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x02, 0x01, 0xfc, 0x08,
  0xe4, 0x4f, 0x40, 0xbf,
  0x02, 0xfb, 0x17, 0xe0,
  0xcf, 0x40, 0xff, 0x06,
  0xfc, 0x3b, 0xf0, 0xff,
  0x00, 0x00, 0x00, 0xc0,
  0x01, 0x00, 0x00, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0xfc, 0x08,
  0xe4, 0x4f, 0x40, 0xbf,
  0x02, 0xfb, 0x17, 0xe0,
  0xcf, 0x40, 0xff, 0x06,
  0xfc, 0x3b, 0xf0, 0xff,
  0x00, 0x00, 0x00, 0xc0,
  0x01, 0x00, 0x00, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x02, 0x01, 0xfc, 0x08,
  0xe4, 0x4f, 0x40, 0xbf,
  0x02, 0xfb, 0x17, 0xe0,
  0xcf, 0x40, 0xff, 0x06,
  0xfc, 0x3b, 0xf0, 0xff,
  0x00, 0x00, 0x00, 0xc0,
  0x01, 0x00, 0x00, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x03, 0x01, 0xfc, 0x08,
  0xe4, 0x4f, 0x40, 0xbf,
  0x02, 0xfb, 0x17, 0xe0,
  0xcf, 0x40, 0xff, 0x06,
  0xfc, 0x3b, 0xf0, 0xff,
  0x00, 0x00, 0x00, 0xc0,
  0x01, 0x00, 0x00, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x03, 0x01, 0xfc, 0x08,
  0xe4, 0x4f, 0x40, 0xbf,
  0x02, 0xfb, 0x17, 0xe0,
  0xcf, 0x40, 0xff, 0x06,
  0xfc, 0x3b, 0xf0, 0xff,
  0x00, 0x00, 0x00, 0xc0,
  0x01, 0x00, 0x00, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x03, 0x01, 0xfc, 0x08,
  0xe4, 0x4f, 0x40, 0xbf,
  0x02, 0xfb, 0x17, 0xe0,
  0xcf, 0x40, 0xff, 0x06,
  0xfc, 0x3b, 0xf0, 0xff,
  0x00, 0x00, 0x00, 0xc0,
  0x01, 0x00, 0x00, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x03, 0x01, 0xfc, 0x08,
  0xe4, 0x4f, 0x40, 0xbf,
  0x02, 0xfb, 0x17, 0xe0,
  0xcf, 0x40, 0xff, 0x06,
  0xfc, 0x3b, 0xf0, 0xff,
  0x00, 0x00, 0x00, 0xc0,
  0x01, 0x00, 0x00, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x03, 0x01, 0xfc, 0x08,
  0xe4, 0x4f, 0x40, 0xbf,
  0x02, 0xfb, 0x17, 0xe0,
  0xcf, 0x40, 0xff, 0x06,
  0xfc, 0x3b, 0xf0, 0xff,
  0x00, 0x00, 0x00, 0xc0,
  0x01, 0x00, 0x00, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x03, 0x01, 0xfc, 0x08,
  0xe4, 0x4f, 0x40, 0xbf,
  0x02, 0xfb, 0x17, 0xe0,
  0xcf, 0x40, 0xff, 0x06,
  0xfc, 0x3b, 0xf0, 0xff,
  0x5b, 0x88, 0x6c, 0xb9,
  0x00, 0x00, 0x00, 0x0d,
  0x07, 0x00, 0x00, 0x00,
  0x61, 0x23, 0x65, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x08,
  0x40, 0x00, 0x02, 0x10,
  0x80, 0x00, 0x04, 0x20,
  0x00, 0x01, 0x08, 0x40,
  0x00, 0x00, 0x00, 0x00,
  0xb2, 0x86, 0x2f, 0x0b,
  0x00, 0x00, 0x00, 0x0e,
  0x03, 0x00, 0x00, 0x00,
  0xe6, 0xce, 0xa7, 0xc8,
  0x80, 0xe3, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xe0,
  0x51, 0x8e, 0xcf, 0x05,
  0x00, 0x00, 0x00, 0x10,
  0x04, 0x00, 0x00, 0x00,
  0xbc, 0xdf, 0xa0, 0x8a,
  0x00, 0x00, 0x00, 0xc0,
  0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x7f,
  0x2c, 0x45, 0xa8, 0xdc,
  0x00, 0x00, 0x00, 0x11,
  0x0e, 0x00, 0x00, 0x00,
  0x68, 0x16, 0x7d, 0xd8,
  0x00, 0x00, 0x09, 0x78,
  0x00, 0x40, 0x18, 0x17,
  0x7b, 0x00, 0x00, 0x82,
  0xe3, 0x01, 0x00, 0x00,
  0x80, 0x40, 0xa8, 0x88,
  0xff, 0xff, 0xff, 0xff,
  0x00, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x80, 0xff,
  0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xc3,
  0x15, 0xa6, 0x0e, 0xa0,
  0x00, 0x00, 0x00, 0x14,
  0x05, 0x00, 0x00, 0x00,
  0x19, 0x1e, 0x9c, 0xc7,
  0x00, 0x00, 0x00, 0x10,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xf0, 0x3f,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x6a, 0x81, 0x40, 0xf9,
  0x00, 0x00, 0x00, 0x16,
  0x03, 0x00, 0x00, 0x00,
  0xa5, 0x12, 0x37, 0x98,
  0x00, 0x00, 0x00, 0x90,
  0x00, 0x40, 0x24, 0x42,
  0x24, 0x42, 0x24, 0x42,
  0xfc, 0x1d, 0x31, 0x7e,
  0x00, 0x00, 0x00, 0x1a,
  0x01, 0x00, 0x00, 0x00,
  0x2f, 0x37, 0xce, 0xf7,
  0x00, 0x00, 0x00, 0xb0,
  0x90, 0x6c, 0x25, 0xea,
  0x00, 0x00, 0x00, 0x1b,
  0x46, 0x00, 0x00, 0x00,
  0x1b, 0x7e, 0x6d, 0xcc,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x0c, 0x00, 0x11,
  0x00, 0x00, 0xfc, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xf1, 0xff,
  0xff, 0x3d, 0x7f, 0xfe,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0e, 0x00,
  0x00, 0xc2, 0x80, 0x01,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x0c, 0x08, 0x77,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xf7, 0x88,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x0c, 0x00, 0x10,
  0x00, 0x01, 0xfc, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xf1, 0xff,
  0xff, 0x3d, 0x7f, 0xfe,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0e, 0x00,
  0x00, 0xc2, 0x80, 0x01,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x08, 0x77,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xf7, 0x88,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x63, 0x46, 0x8a, 0x7d,
  0x00, 0x00, 0x00, 0x1c,
  0x0b, 0x00, 0x00, 0x00,
  0xeb, 0x22, 0x33, 0x17,
  0x00, 0x88, 0xc6, 0xfa,
  0x00, 0x88, 0xc6, 0xfa,
  0x00, 0x88, 0xc6, 0xfa,
  0x00, 0x88, 0xc6, 0xfa,
  0x00, 0x88, 0xc6, 0xfa,
  0x00, 0x88, 0xc6, 0xfa,
  0x00, 0x88, 0xc6, 0xfa,
  0x00, 0x88, 0xc6, 0xfa,
  0x00, 0x88, 0xc6, 0xfa,
  0x00, 0x88, 0xc6, 0xfa,
  0x00, 0x88, 0xc6, 0xfa,
  0x4c, 0x95, 0x3e, 0xf2,
  0x00, 0x00, 0x00, 0x4e,
  0x02, 0x00, 0x00, 0x00,
  0xca, 0xf1, 0xe8, 0x28,
  0x00, 0x00, 0x40, 0x28,
  0xbb, 0x00, 0x00, 0x00,
  0x5b, 0x78, 0xb8, 0x51,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x21, 0xea, 0x63, 0x7f	
};
static const unsigned char latest_config[] ={
0x0F, 0x03, 0x00, 0xB7, 0x00, 0x00, 0x00, 0x06,
0xDC, 0x00, 0x00, 0x00, 0xE8, 0x2C, 0xE0, 0x86,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x00,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x02,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x04,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x06,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x08,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x0A,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x0C,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x0E,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x10,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x12,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x14,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x16,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x18,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x1A,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x1C,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x1E,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x20,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x22,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x24,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x26,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x28,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x2A,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x2C,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x2E,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x30,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x32,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x34,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x36,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x38,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x3A,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x3C,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x3E,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x40,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x42,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x44,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x46,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x48,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x4A,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x4C,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x4E,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x50,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x52,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x54,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x56,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x58,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x5A,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x5C,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x5E,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x60,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x62,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x64,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x66,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x68,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x6A,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x6C,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x6E,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x70,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x72,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x74,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x76,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x78,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x7A,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x7C,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x7E,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x80,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x82,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x84,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x86,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x88,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x8A,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x8C,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x8E,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x90,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x92,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x94,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x96,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x98,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x9A,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x9C,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0x9E,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xA0,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xA2,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xA4,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xA6,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xA8,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xAA,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xAC,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xAE,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xB0,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xB2,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xB4,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xB6,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xB8,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xBA,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xBC,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xBE,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xC0,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xC2,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xC4,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xC6,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xC8,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xCA,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xCC,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xCE,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xD0,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xD2,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xD4,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xD6,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xD8,
0x00, 0xEC, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F, 0xDA,
0xFB, 0x10, 0x28, 0xA5, 0x00, 0x00, 0x00, 0x07,
0x03, 0x00, 0x00, 0x00, 0x97, 0xAC, 0xB7, 0xC5,
0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0xF0, 0xFF,
0xFF, 0x03, 0x00, 0x00, 0x3C, 0x2E, 0x2C, 0x8D,
0x00, 0x00, 0x00, 0x08, 0x26, 0x00, 0x00, 0x00,
0x4A, 0x64, 0x0B, 0xD0, 0x00, 0x00, 0x00, 0x00,
0xFF, 0xFB, 0xDF, 0xFF, 0x00, 0x00, 0x00, 0x80,
0xFE, 0xF7, 0xBF, 0xFF, 0x00, 0x00, 0x00, 0x80,
0xFD, 0xEF, 0x7F, 0xFF, 0x00, 0x00, 0x00, 0x80,
0xFB, 0xDF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x80,
0xF7, 0xBF, 0xFF, 0xFD, 0x00, 0x00, 0x00, 0x80,
0xEF, 0x7F, 0xFF, 0xFB, 0x00, 0x00, 0x00, 0x80,
0xDF, 0xFF, 0xFE, 0xF7, 0x00, 0x00, 0x00, 0x80,
0xBF, 0xFF, 0xFD, 0xEF, 0x00, 0x00, 0x00, 0x80,
0x7F, 0xFF, 0xFB, 0xDF, 0x00, 0x00, 0x00, 0x80,
0xFF, 0xFE, 0xF7, 0xBF, 0x00, 0x00, 0x00, 0x80,
0xFF, 0xFD, 0xEF, 0x7F, 0x00, 0x00, 0x00, 0x40,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x24, 0x49, 0x92, 0x24, 0x00, 0x00, 0x00, 0x40,
0x49, 0x92, 0x24, 0x49, 0x00, 0x00, 0x00, 0xC0,
0x6D, 0xDB, 0xB6, 0x6D, 0x00, 0x00, 0x00, 0x40,
0x92, 0x24, 0x49, 0x92, 0x00, 0x00, 0x00, 0xC0,
0xB6, 0x6D, 0xDB, 0xB6, 0x00, 0x00, 0x00, 0x40,
0xDB, 0xB6, 0x6D, 0xDB, 0x00, 0x00, 0x00, 0xC0,
0xFF, 0xFF, 0xFF, 0xFF, 0x4C, 0xE9, 0xE6, 0x5B,
0x00, 0x00, 0x00, 0x09, 0x58, 0x00, 0x00, 0x00,
0x55, 0x9A, 0x8B, 0x66, 0x00, 0x00, 0x00, 0xC0,
0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x03, 0x01, 0xFC, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x02, 0x01, 0xFC, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x02, 0x01, 0xFC, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x02, 0x01, 0xFC, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x02, 0x01, 0xFC, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x03, 0x01, 0xFC, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x03, 0x01, 0xFC, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x03, 0x01, 0xFC, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x03, 0x01, 0xFC, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x03, 0x01, 0xFC, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x03, 0x01, 0xFC, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x50, 0xFD, 0xBD, 0xA6,
0x00, 0x00, 0x00, 0x0E, 0x03, 0x00, 0x00, 0x00,
0xE6, 0xCE, 0xA7, 0xC8, 0x80, 0xE3, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x29, 0x6C, 0xC5, 0xA5, 0x00, 0x00, 0x00, 0x10,
0x04, 0x00, 0x00, 0x00, 0xBC, 0xDF, 0xA0, 0x8A,
0x00, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
0xBC, 0x04, 0x74, 0xAA, 0x00, 0x00, 0x00, 0x11,
0x0E, 0x00, 0x00, 0x00, 0x68, 0x16, 0x7D, 0xD8,
0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x11,
0x09, 0x00, 0x00, 0x82, 0xE3, 0x3D, 0x00, 0x00,
0x80, 0xC0, 0x00, 0x91, 0xFF, 0xFF, 0xFF, 0xFF,
0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
0x00, 0x80, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x80,
0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x61, 0xC0,
0x00, 0x00, 0x00, 0x00, 0x61, 0xC0, 0x80, 0x87,
0x81, 0x97, 0xC0, 0x94, 0x00, 0x00, 0x00, 0x1C,
0x0B, 0x00, 0x00, 0x00, 0xEB, 0x22, 0x33, 0x17,
0x00, 0x88, 0xC6, 0xFA, 0x00, 0x88, 0xC6, 0xFA,
0x00, 0x88, 0xC6, 0xFA, 0x00, 0x88, 0xC6, 0xFA,
0x00, 0x88, 0xC6, 0xFA, 0x00, 0x88, 0xC6, 0xFA,
0x00, 0x88, 0xC6, 0xFA, 0x00, 0x88, 0xC6, 0xFA,
0x00, 0x88, 0xC6, 0xFA, 0x00, 0x88, 0xC6, 0xFA,
0x00, 0x88, 0xC6, 0xFA, 0x4C, 0x95, 0x3E, 0xF2,
0x00, 0x00, 0x00, 0x4E, 0x02, 0x00, 0x00, 0x00,
0xCA, 0xF1, 0xE8, 0x28, 0x00, 0x00, 0x70, 0x28,
0xBB, 0x00, 0x00, 0x00, 0xF6, 0x7F, 0xC2, 0x55,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x23, 0x36, 0xF3, 0xB5,
};

/*
 * Obtained from encoding the S32G274-EVB configuration firmware from
 * sja1105 driver
 * To regenerate this, use the file with the following command:
 * 'xxd -i <filename>'
 */


static const struct sja1105_cfgs_s sja1105_evb_cfgs_m[] = {
	{
		.devid = SJA1105_VAL_DEVICEID_1_1,
		.cs = 0,
		.bin_len = ARRAY_SIZE(latest_config),
		.cfg_bin = latest_config
	},
	{ 0x0UL, 0, 0, NULL }
};

static const struct udevice_id sja1105_ids[] = {
	{
		.compatible = "nxp,sja1105-s32gevb-fw-loader",
		.data = (ulong)&sja1105_evb_cfgs_m[0]
	},
	{}
};

U_BOOT_DRIVER(sja1105_fw_loader) = {
	.name	= "sja1105_fw_loader",
	.id	= UCLASS_MISC,
	.of_match = sja1105_ids,
	.probe	= sja11105_dm_probe,
	.priv_auto = sizeof(struct sja_parms),
};

static int get_sja1105_device(struct udevice **dev, struct sja_parms *sjap)
{
	struct udevice *parent;
	size_t i;
	int ret;
	ofnode node;

	for (i = 0; i < ARRAY_SIZE(sja1105_ids); i++) {
		if (!sja1105_ids[i].compatible)
			continue;

		node = ofnode_by_compatible(ofnode_null(),
					    sja1105_ids[i].compatible);
		if (!ofnode_valid(node))
			continue;

		ret = uclass_get_device_by_ofnode(UCLASS_MISC, node, dev);
		if (ret)
			continue;

		parent = dev_get_parent(*dev);
		if (!parent)
			continue;

		if (spi_chip_select(*dev) == sjap->cs &&
		    parent->seq_ == sjap->bus)
			return 0;
	}

	return -EINVAL;
}

// SGMII regs are accessed indirectly through
// a base register at 0x3fc and offsets in the range:
// 0x0...0x4.............0x3f8
// Base address should be comprised of bits 23:8 of the location
// so a base address has 4 hex digits.
// The formula of the register accessed is
// (base << 8) + (offset / 4), so there are 255 register offsets
// To access register 200 you do 200 * 4 = 800 (0x320)
u32 read_sgmii_register(struct sja_parms *sjap, int port, u32 base, u32 offset) {
	unsigned int val;
	int ret;
  
	ret = sja1105_write_reg32_v2(sjap, SGMII_PORT_BASE_ADDR(port), SGMII_BASE_REGISTER, base);
	if (ret < 0) {
		printf("Error writing to SGMII base register!\n");
		return ret;
	}

	// For these registers the documentation offset is correct
	val = sja1105_read_reg32_v2(sjap, SGMII_PORT_BASE_ADDR(port), offset * 4);

	return val;
}

u32 write_sgmii_register(struct sja_parms *sjap, int port, u32 base, u32 offset, u32 val) {
	int ret;
  
	ret = sja1105_write_reg32_v2(sjap, SGMII_PORT_BASE_ADDR(port), SGMII_BASE_REGISTER, base);
	if (ret < 0) {
		printf("Error writing to SGMII base register!\n");
		return ret;
	}

	// For these registers the documentation offset is correct
	val = sja1105_write_reg32_v2(sjap, SGMII_PORT_BASE_ADDR(port), offset * 4, val);

	return val;
}

// There are 27 steps documented in the SJA1110 Software Manual
// Steps 1-5 program the PCS to a certain operating mode (e.g fixed speed or auto-neg)
// Steps 6-16 program and startup PMA TX
// Steps 17-27 program and startup PMA RX
// Step 27 checks PCS RX Link status
int init_sgmii_port(struct sja_parms *sjap, int port) {
	int ret, count = 20, val;

	// Step 1: Reset SGMII port (RST = 1)
	printf("Resetting SGMII port %d\n", port);
	ret = write_sgmii_register(sjap, port, SGMII_SR_MII_CTRL_BASE, SGMII_SR_MII_CTRL_OFFSET, 0x8000);
	if (ret < 0) {
		printf("Error writing SGMII CTRL register port: %d\n", port);
		return ret;
	}
	// Step 2: Poll the reset bit (RST = 0)
	printf("Waiting for reset to complete\n");
	while (true) {
		val = read_sgmii_register(sjap, port, SGMII_SR_MII_CTRL_BASE, SGMII_SR_MII_CTRL_OFFSET);
		count--;
		if ((val & 0x8000) && (count >= 0)) {
			printf("Reset still on\n");
		} else {
			break;
		}
	}
	if (val & 0x8000) {
		printf("Error: Reset did not complete. Abort.\n");
		return -1;
	}
	// Step 3: Program fixed PCS speed of 1G (AN_ENABLE=0 SS6=0 SS13=0)
	printf("Setting fixed PCS speed: 1G\n");
	ret = write_sgmii_register(sjap, port, SGMII_SR_MII_CTRL_BASE, SGMII_SR_MII_CTRL_OFFSET, 0x140);
	if (ret < 0) {
		printf("Error setting PCS speed\n");
		return ret;
	}
	// Step 4: Program PCS for non-2.5G operation (EN_2_5_MODE=0 MAC_AUTO_SW=0)
	printf("Setting PCS to non-2.5G operation\n");
	ret = write_sgmii_register(sjap, port, SGMII_VR_MII_DIG_CTRL1_BASE, SGMII_VR_MII_DIG_CTRL1_OFFSET, 0x2000);
	if (ret < 0) {
		printf("Error setting PCS to non-2.5G operation\n");
		return ret;
	}

	// Step 5: Program PCS mode to SGMII for fixed speed (PCS_MODE = 0x0 TX_CONFIG= 0x0)
	ret = write_sgmii_register(sjap, port, SGMII_VR_MII_AN_CTRL_BASE, SGMII_VR_MII_AN_CTRL_OFFSET, 0x0);
	if (ret < 0) {
		printf("Error programing PCS mode to SGMII for fixed speed\n");
		return ret;
	}

	// Step 6: Program transmitter PLL feedback divider settings for correct oscillation frequency (TXPLL_FBDIV=0x19)
	// This setting is for 1G/100M/10M or Autoneg
	ret = write_sgmii_register(sjap, port, SGMII_TXPLL_CONTROL_0_BASE, SGMII_TXPLL_CONTROL_0_OFFSET, 0x19);
	if (ret < 0) {
		printf("Error programing transmitter PLL feedback divider\n");
		return ret;
	}
	// Step 7: Programming transmitter PLL reference divider settings for correct oscillation frequency
	// This setting is for 1G/100M/10M or Autoneg
	ret = write_sgmii_register(sjap, port, SGMII_TXPLL_CONTROL_1_BASE, SGMII_TXPLL_CONTROL_1_OFFSET, 0x1);
	if (ret < 0) {
		printf("Error programing transmitter PLL reference divider\n");
		return ret;
	}
	// Step 8: Program transmitter amplitude setting to 675mV-difpp
	ret = write_sgmii_register(sjap, port, SGMII_LANE_DRIVER1_0_BASE, SGMII_LANE_DRIVER1_0_OFFSET, 0x5000);
	if (ret < 0) {
		printf("Error programing transmitter amplitude setting.\n");
		return ret;
	}
	// Step 9: Program transmitter amplitude trimming to no trimming
	ret = write_sgmii_register(sjap, port, SGMII_LANE_DRIVER2_0_BASE, SGMII_LANE_DRIVER2_0_OFFSET, 0xFFFF);
	if (ret < 0) {
		printf("Error programing transmitter 0 amplitude trimming to no trimming.\n");
		return ret;
	}

	// Step 10: Program transmitter amplitude trimming to no trimming
	ret = write_sgmii_register(sjap, port, SGMII_LANE_DRIVER2_1_BASE, SGMII_LANE_DRIVER2_1_OFFSET, 0x02ff);
	if (ret < 0) {
		printf("Error programing transmitter 1 amplitude trimming to no trimming.\n");
		return ret;
	}

	// Step 11: Enable transmitter termination. Program TXPLL bandwidth control
	ret = write_sgmii_register(sjap, port, SGMII_LANE_TRIM_BASE, SGMII_LANE_TRIM_OFFSET, 0x0b65);
	if (ret < 0) {
		printf("Error enabling transmitter termination.\n");
		return ret;
	}

	// Step 12: Select PCS as transmitter data source.
	ret = write_sgmii_register(sjap, port, SGMII_LANE_DATAPATH_1_BASE, SGMII_LANE_DATAPATH_1_OFFSET, 0x0);
	if (ret < 0) {
		printf("Error selecting PCS as transmitter data source.\n");
		return ret;
	}

	// Step 13: Enable transmitter PLL
	ret = write_sgmii_register(sjap, port, SGMII_POWERDOWN_ENABLE_BASE, SGMII_POWERDOWN_ENABLE_OFFSET, 0x0bec);
	if (ret < 0) {
		printf("Error enabling transmitter PLL.\n");
		return ret;
	}

	// Step 14: Wait until transmitter PLL is in lock by polling PLL lock indicator until it is set.
	printf("Waiting for PLL to lock\n");
	count = 20;
	while (true) {
		val = read_sgmii_register(sjap, port, SGMII_TXPLL_CONTROL_0_BASE, SGMII_TXPLL_CONTROL_0_OFFSET);
		// bit 12 is TXPLL_LOCK
		count--;
		if (!(val & 0x1000) && (count >= 0)) {
			printf("Waiting on PLL lock\n");
		} else {
			break;
		}
	}

	if (!(val & 0x1000)) {
		printf("Error: PLL lock timeout.\n");
		return -1;
	} else {
		printf("PLL Locked\n");
	}

	// Step 15:  Release reset of PMA TX to enable data flow from PCS TX.
	// Enable transmitter circuit.
	// Enable receiver biasing circuits
	ret = write_sgmii_register(sjap, port, SGMII_POWERDOWN_ENABLE_BASE, SGMII_POWERDOWN_ENABLE_OFFSET, 0x02ac);
	if (ret < 0) {
		printf("Error releasing reset of PMA TX or enabling TX circuit, or RX biasing circuits.\n");
		return ret;
	}

	// Step 16: Program receiver PLL feedback divider settings for correct oscillation frequency.
	ret = write_sgmii_register(sjap, port, SGMII_RXPLL_CONTROL_0_BASE, SGMII_RXPLL_CONTROL_0_OFFSET, 0x64);
	if (ret < 0) {
		printf("Error programming RX PLL feedback divider.\n");
		return ret;
	}

	// Step 17: Program receiver PLL reference divider settings for correct oscillation frequency.
	ret = write_sgmii_register(sjap, port, SGMII_RXPLL_CONTROL_1_BASE, SGMII_RXPLL_CONTROL_1_OFFSET, 0x1);
	if (ret < 0) {
		printf("Error programming RX PLL reference divider.\n");
		return ret;
	}

	// Step 18: Enable receiver termination
	ret = write_sgmii_register(sjap, port, SGMII_LANE_TRIM_BASE, SGMII_LANE_TRIM_OFFSET, 0x0be5);
	if (ret < 0) {
		printf("Error enabling RX termination.\n");
		return ret;
	}

	// Step 19: Program threshold for receiver signal detector to 90mV-difpp
	ret = write_sgmii_register(sjap, port, SGMII_RX_DATA_DETECT_BASE, SGMII_RX_DATA_DETECT_OFFSET, 0x5);
	if (ret < 0) {
		printf("Error programming threshold for RX Signal detect to 90mV-difpp.\n");
		return ret;
	}

	// Step 20: Enable receiver signal detector
	ret = write_sgmii_register(sjap, port, SGMII_POWERDOWN_ENABLE_BASE, SGMII_POWERDOWN_ENABLE_OFFSET, 0x6ac);
	if (ret < 0) {
		printf("Error enabling RX Signal detector.\n");
		return ret;
	}

	// Step 21: Program continuous-time linear 0x1F8042 equalizer (CTLE) settings
	ret = write_sgmii_register(sjap, port, SGMII_RX_CDR_CTLE_BASE, SGMII_RX_CDR_CTLE_OFFSET, 0x212a);
	if (ret < 0) {
		printf("Error programming CTLE.\n");
		return ret;
	}

	// Step 22: Poll RX Signal detector to indicate that there is a signal on RX input
	printf("Waiting for RX Signal detect\n");
	count = 20;
	while (true) {
		val = read_sgmii_register(sjap, port, SGMII_RX_DATA_DETECT_BASE, SGMII_RX_DATA_DETECT_OFFSET);
		// bit 4 is Signal Detect
		count--;
		if ((val & 0x10) && (count >= 0)) {
			printf("Waiting for RX Signal detect\n");
		} else {
			break;
		}
	}

	if (val & 0x10) {
		printf("Error: RX Signal detect timeout.\n");
		return -1;
	} else {
		printf("RX Signal detected\n");
	}

	// Step 23: Enable receiver PLL and CDR. Enable receiver CTLE
	ret = write_sgmii_register(sjap, port, SGMII_POWERDOWN_ENABLE_BASE, SGMII_POWERDOWN_ENABLE_OFFSET, 0x04bc);
	if (ret < 0) {
		printf("Error programming RX PLL and CDR and enabling RX CTLE.\n");
		return ret;
	}
	// Step 24: Wait until PLL and CDR are in lock by polling PLL lock indicator until it is set.2
	printf("Waiting for PLL and CDR lock\n");
	count = 20;
	while (true) {
		val = read_sgmii_register(sjap, port, SGMII_RXPLL_CONTROL_0_BASE, SGMII_RXPLL_CONTROL_0_OFFSET);
		// bit 11 is RXPLL_LOCK
		count--;
		if (!(val & 0x800) && (count >= 0)) {
			printf("Waiting for PLL and CDR lock\n");
		} else {
			break;
		}
	}
	if (!(val & 0x800)) {
		printf("Error: PLL and CDR lock timeout.\n");
		return -1;
	} else {
		printf("PLL and CDR locked.\n");
	}

	// Step 25: Release reset of PMA RX and enable data flow to PCS RX
	ret = write_sgmii_register(sjap, port, SGMII_POWERDOWN_ENABLE_BASE, SGMII_POWERDOWN_ENABLE_OFFSET, 0x049c);
	if (ret < 0) {
		printf("Error releasing PMA RX reset.\n");
		return ret;
	}

	// Step 26: Determine if PCS RX link is up by polling link status.2
	printf("Waiting on PCS RX link up\n");
	count = 20;
	while (true) {
		val = read_sgmii_register(sjap, port, SGMII_SR_MII_STS_BASE, SGMII_SR_MII_STS_OFFSET);
		// bit 2 is LINK_STS
		count--;
		if (!(val & 0x4) && (count >= 0)) {
			printf("Waiting on PCS RX link up\n");
		} else {
			break;
		}
	}
	if (!(val & 0x4)) {
		printf("Error: PLL and CDR lock timeout.\n");
		return -1;
	} else {
		printf("PLL and CDR locked.\n");
	}

	// Step 27: Determine if auto-negotiation has completed.
	printf("Waiting on auto-negotation completed.\n");
	count = 20;
	while (true) {
		val = read_sgmii_register(sjap, port, SGMII_SR_MII_STS_BASE, SGMII_SR_MII_STS_OFFSET);
		// bit 2 is LINK_STS
		count--;
		if (!(val & 0x4) && (count >= 0)) {
			printf("Waiting on auto-negotiation completed\n");
		} else {
			break;
		}
	}
	if (!(val & 0x4)) {
		printf("Error: Auto-negotiation timeout.\n");
		return -1;
	} else {
		printf("Auto-negotiation completed.\n");
	}

	return 0;
}

#define TX_100BASE_POWER_DOWN_CONTROL  0x60
#define TX_100BASE_VM_DAC_CONTROL0     0x708
#define OTP_SHADOW1_17_ADDR            0x144
#define TX_100BASE_TRIM_CONFIG         0x4c
#define TX_100BASE_BASIC_CONTROL_REG   0x00
#define TX_100BASE_AFE_SPARE           0x724
#define TX_100BASE_MODE_CONTROL_STATUS 0x44
#define TX_100BASE_MISC_PCS_CONTROL0   0x714
#define TX_100BASE_BASIC_STATUS        0x04

// There are 2 phases in the initialization sequence
// Phase 1 is common to all sequences
// Phase 2 is force-mode init sequence (Auto-neg OFF, Auto-mdix OFF, Force 100/10,FD)
int init_100base_tx_port1(struct sja_parms *sjap) {
	int ret, val;
	// This is copied from OTP SHADOW1_17 register
	u32 txamp_10bt;
	int count;

	// Phase 1
	// Common sequence
	
	// Step 1: Clear true power down control bit to bring CBTX out of power down mode
	ret = sja1105_write_reg32_v2(sjap, TX_100BASE_BASE_ADDR, TX_100BASE_POWER_DOWN_CONTROL, 0x060);
	if (ret < 0) {
		printf("Error Clearing true power down control bit\n");
		return ret;
	}
	// Step 1a: Enable transmitter with internal bias current
	ret = sja1105_write_reg32_v2(sjap, TX_100BASE_BASE_ADDR, TX_100BASE_VM_DAC_CONTROL0, 0x907b);
	if (ret < 0) {
		printf("Error enabling transmitter\n");
		return ret;
	}

	// Step 2 Copy CBTX ZQ trim and TXAMP_10BT value from OTP shadow register to CBTX_ TRIM_CONFIG
	// Trimming information seems to come from SHADOW1_27
	/*
		Pseudocode:
		// Obtain trim code from OTP register SHADOW1_27
		code = (SHADOW1_27 >>16) & 0x3;
		if code == 0x2 then
			// Use init slow case (see common sequence)
		else if code == 0x0 then
			// Use init typical case (see common sequence)
		else if code == 0x1 then
			// Use init fast case (see common sequence)
		end
	*/
	val = sja1105_read_reg32_v2(sjap, OTP_CTRL_BASE_ADDR, OTP_SHADOW1_17_ADDR);
	printf("SHADOW1_17 REG: 0x%x\n", val);

	// As far as I can tell we need the bottom 16 bits
	txamp_10bt = val & 0xffff;

	ret = sja1105_write_reg32_v2(sjap, TX_100BASE_BASE_ADDR, TX_100BASE_TRIM_CONFIG, txamp_10bt);
	if (ret < 0) {
		printf("Error setting TXAMP_10BT value from shadow register\n");
		return ret;
	}

	// Step 3: Soft reset to the IP
	ret = sja1105_write_reg32_v2(sjap, TX_100BASE_BASE_ADDR, TX_100BASE_BASIC_CONTROL_REG, 0x8000);
	if (ret < 0) {
		printf("Error enabling transmitter\n");
		return ret;
	}

	// Step 4: Poll Basic Control Register bit 15 until out of reset
	printf("Waiting to come out of reset.\n");
	count = 20;
	while (true) {
		val = sja1105_read_reg32_v2(sjap, TX_100BASE_BASE_ADDR, TX_100BASE_BASIC_CONTROL_REG);
		// bit 2 is LINK_STS
		count--;
		if ((val & 0x8000) && (count >= 0)) {
			printf("Waiting to come out of reset\n");
		} else {
			break;
		}
	}
	if (val & 0x8000) {
		printf("Error: Timeout waiting to come out of reset.\n");
		return -1;
	} else {
		printf("100BASE-TX Reset complete.\n");
	}

	// Step 5: Reference trimming for ADC LDO
	ret = sja1105_write_reg32_v2(sjap, TX_100BASE_BASE_ADDR, TX_100BASE_AFE_SPARE, 0x2);
	if (ret < 0) {
		printf("Error with reference trimming for ADC LDO\n");
		return ret;
	}

	// Step 5abc: TODO Figure out if we need slow, typical or fast sample setting, the typical case does nothing
	// so skip this stpe for now

	// Phase 2: Force mode
	// Step 1 was the common init sequence above

	// Step 2: Disable auto-mdix and configure in MDI mode/MDIX TODO: determine which we need
	// Set MDI for now
	ret = sja1105_write_reg32_v2(sjap, TX_100BASE_BASE_ADDR, TX_100BASE_MODE_CONTROL_STATUS, 0x0);
	if (ret < 0) {
		printf("Error disabling auto mdix\n");
		return ret;
	}

	// Step 3: Force mode by programming BASIC_CONTROL registers
    // Disable auto negotiation, and based on requirement configure 100M or 10M mode
	// Programming it for 100M FD
	ret = sja1105_write_reg32_v2(sjap, TX_100BASE_BASE_ADDR, TX_100BASE_BASIC_CONTROL_REG, 0x2100);
	if (ret < 0) {
		printf("Error setting 100M FD\n");
		return ret;
	}

	// Step 4: Disable 10BT voltage mode driver
	ret = sja1105_write_reg32_v2(sjap, TX_100BASE_BASE_ADDR, TX_100BASE_MISC_PCS_CONTROL0, 0x4);
	if (ret < 0) {
		printf("Error disabling 10BT voltage mode divider\n");
		return ret;
	}

	// Step 5: Poll BASIC STATUS reg, check for link up
	printf("Wait for link UP.\n");
	count = 100000;
	while (true) {
		val = sja1105_read_reg32_v2(sjap, TX_100BASE_BASE_ADDR, TX_100BASE_BASIC_STATUS);
		// bit 2 is LINK_STS
		count--;
		if (!(val & 0x4) && (count >= 0)) {
			//printf("Waiting to come out of reset\n");
		} else {
			break;
		}
	}
	if (!(val & 0x4)) {
		printf("Error: Timeout waiting for link UP.\n");
		return -1;
	} else {
		printf("100BASE-TX Link status: UP.\n");
		printf("count: %d\n", count);
	}
	return 0;
}

// Port 1 is 100BASE-TX
//Port 3 is SGMII
int init_ports_fernride(struct udevice *dev) {
	struct sja_parms *sjap = dev_get_priv(dev);
	unsigned int val;
	int ret;


	if (!sjap) {
		printf("No access point device!\n");
		return -1;
	}
	
	val = sja1105_read_reg32(sjap, 0x00000000ull);
	printf("Device Id: 0x%x\n", val);

	printf("\nInitializing SGMII port 3:\n");
	ret = init_sgmii_port(sjap, 3);
	if (ret < 0) {
		printf("Error initializing SGMII port\n");
		return ret;
	}
	printf("SGMII init complete\n");

	printf("\nInitializing 100BASE-TX port:\n");
	ret = init_100base_tx_port1(sjap);
	if (ret < 0) {
		printf("Error initializing 100base-tx port1\n");
		return ret;
	}
	printf("100BASE-TX init complete\n");

	return 0;
}

// 0 for read, 1 for write
int spi_cmd(struct udevice *dev, int write, u32 base, u32 offset, u32 val) {
	struct sja_parms *sjap = dev_get_priv(dev);
	u32 ret_val;
	int ret;

	if (!write) {
		ret_val = sja1105_read_reg32_v2(sjap, base, offset);
		printf("RD[0x%x] 0x%x\n", base + offset, ret_val);
	} else {
		ret = sja1105_write_reg32_v2(sjap, base, offset, val);
		if (ret < 0) {
			printf("Error writing to SPI register\n");
			return ret;
		}
	}

	return 0;
}

int sgmii_cmd(struct udevice *dev, int write, u32 port, u32 base, u32 offset, u32 val) {
	struct sja_parms *sjap = dev_get_priv(dev);
	u32 ret_val;
	int ret;

	if (!write) {
		ret_val = read_sgmii_register(sjap, port, base, offset);
		printf("RD[0x%x] 0x%x\n", (base<<8) + offset, ret_val);
	} else {
		ret = write_sgmii_register(sjap, port, base, offset, val);
		if (ret < 0) {
			printf("Error writing to SGMII register\n");
			return ret;
		}
	}

	return 0;
}

static int do_sja_cmd(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
{
	char *cp = NULL, *options = NULL;
	struct udevice *dev;
	struct sja_parms sjap;
	int ret;

	/* Parse SPI data */
	sjap.cs = 0;
	sjap.bus = CONFIG_DEFAULT_SPI_BUS;

	if (argc < 2)
		return CMD_RET_USAGE;

	/* Check if last argument is spi:cs */
	if (argc > 2 && !strchr(argv[argc - 1], ',')) {
		sjap.bus = simple_strtoul(argv[argc - 1], &cp, 10);
		if (*cp == ':') {
			sjap.cs = simple_strtoul(cp + 1, &cp, 10);
		} else {
			sjap.cs = sjap.bus;
			sjap.bus = CONFIG_DEFAULT_SPI_BUS;
		}
	}

	ret = get_sja1105_device(&dev, &sjap);
	if (ret) {
		printf("Failed to get SJA device on SPI %u:%u\n",
		       sjap.bus, sjap.cs);
		return CMD_RET_FAILURE;
	}

	if (!strcmp(argv[1], "probe")) {
		printf("Probe SJA1105\n");
		sja1105_reset_ports(dev);
	} else if (!strcmp(argv[1], "spi")) {
		u32 write, base, offset, val;
		write = simple_strtoul(argv[2], NULL, 16);
		base = simple_strtoul(argv[3], NULL, 16);
		offset = simple_strtoul(argv[4], NULL, 16);
		val = simple_strtoul(argv[5], NULL, 16);
		spi_cmd(dev, write, base, offset, val);
	} else if (!strcmp(argv[1], "load_config")) { 
		ret = load_config_file(dev);
		if (ret)
			return CMD_RET_FAILURE;
	} else if (!strcmp(argv[1], "status")) { 
		struct sja_parms *sjap = dev_get_priv(dev);
		ret = display_status_regs(sjap);
		if (ret) {
			return CMD_RET_FAILURE;
		}
	} else if (!strcmp(argv[1], "sgmii")) { 
		u32 write, port, base, offset, val;
		write = simple_strtoul(argv[2], NULL, 16);
		port = simple_strtoul(argv[3], NULL, 16);
		base = simple_strtoul(argv[4], NULL, 16);
		offset = simple_strtoul(argv[5], NULL, 16);
		val = simple_strtoul(argv[6], NULL, 16);
		sgmii_cmd(dev, write, port, base, offset, val);
	} else if (!strcmp(argv[1], "info")) {
		ret = sja1105_print_info(dev);
		if (ret)
			return CMD_RET_FAILURE;
	} else if (!strcmp(argv[1], "init_ports")) {
		printf("Setting up FERNRIDE port config\n");
		ret = init_ports_fernride(dev);
	} else if (!strcmp(argv[1], "speed")) {
		if (argc >= 3 && !strchr(argv[2], ':'))
			options = argv[2];
		if (!sja1105_speed_control(dev, options))
			return CMD_RET_USAGE;
	} else {
		return CMD_RET_USAGE;
	}

	return 0;
}

U_BOOT_CMD(
	sja,	9,	1,	do_sja_cmd,
	"SJA1105 control",
	"sja probe [<bus>:]<cs> - Probe SJA and load configuration\n"
	"sja info [<bus>:]<cs> - View registers for SJA\n"
	"sja spi [0(read)|1(write)] [0xbase] [0xoffset] [val(if write)]\n"
	"sja sgmii [0(read)|1(write)] [1-5(port)] [0xbase] [0xoffset] [val(if write)]\n"
	"sja init_ports 2:0 - Set ports according to FERNRIDE specifications\n"
	"sja load_config 2:0 - load configuration file\n"
	"sja speed [<bus>:]<cs> - Read configured speed on all ports\n"
	"sja speed [p0speed,p1speed,p2speed,p3speed,p3speed] [<bus>:]<cs> - Set speed\n"
	"          for ports, speed options [-|disable|10M|100M|1G] when \"-\" is set\n"
	"          given port is not updated\n"
);


